#!/usr/bin/env python

"""
Load a word JSON file saved by this application to Anki.
"""

import os, json, shutil, sys, re

# Add Anki source to path
sys.path.append("../../anki")
from anki.storage import Collection


class Word:
    """
    Wrapper around a single JSON file generated by the web application
    """

    TYPES_ABBR = {
      "Adjective": "adj.",
      "Adverb": "adv.",
      "Article": "a.",
      "Conjunction": "conj.",
      "Determiner": "det.",
      "Interjection": "inter.",
      "Noun": "n.",
      "Particle": "part.",
      "Prefix": "pref.",
      "Preposition": "prep.",
      "Pronoun": "pron.",
      "Verb": "v.",
    }

    def __init__(self, doc):
        self.doc = doc

    def title(self):
        return self.doc['title']

    def rank(self):
        return self.doc['rank']

    def audio_url(self):
        if "audio" in self.doc and self.doc["audio"]["include"]:
            return self.doc["audio"]["url"]
        else:
            return None

    def abbreviated_types(self):
        """
        Return a comma-separated list of the valid types of the word.
        """
        if "types" in self.doc:
            result = []
            for type in self.doc["types"]:
                if type and "include" in type and type["include"]:
                    result.append(self.TYPES_ABBR[type["type"]])
            return ", ".join(result)
        else:
            return None

    def definitions_with_samples(self):
        html = ""
        for type in self.doc["types"]:
            if "include" in type and type["include"]:
                subhtml = ""
                if "definitions" in type:
                    for definition in type["definitions"]:
                        if "include" in definition and definition["include"]:
                            subhtml += "<li>" + self._escape(definition["text"])
                            if "quotations" in definition:
                                first_quotation = True
                                quotation_found = False
                                for quotation in definition["quotations"]:
                                    if "include" in quotation and quotation["include"]:
                                        quotation_found = True
                                        if first_quotation:
                                            subhtml += "<ul>"
                                            first_quotation = False
                                        subhtml += "<li>" + self._escape(quotation["text"]) + "</li>"
                                if quotation_found:
                                    subhtml += "</ul>"
                            subhtml += "</li>"
                # Add the definition if at least one definition was included
                if subhtml:
                    html += "<em>" + type["type"] + "</em>" + "<ul>" + subhtml + "</ul>"

        return html

    def definitions_only(self):
        for type in self.doc["types"]:
            if "definitions" in type and "card_definitions" in type and type["card_definitions"]:
                selected_definitions = []
                for definition in type["definitions"]:
                    if "include" in definition and definition["include"]:
                        selected_definitions.append(definition["text"])
                if selected_definitions:
                    html = "<em>" + type["type"] + "</em>"
                    html += "<ul>"
                    for definition in selected_definitions:
                        html += "<li>" + self._escape(definition) + "</li>"
                    html += "</ul>"

                    # Only one type is  supported
                    return html

        return None

    def image(self):
        if "images" in self.doc:
            for image in self.doc["images"]:
                if "include" in image and image["include"]:
                    return image["thumb_url"]
        return None

    def ipa(self):
        if "ipa" in self.doc:
            return self.doc["ipa"]
        return None

    def translation(self):
        selected_translations = []
        if "translations" in self.doc:
            for translation in self.doc["translations"]:
                if "include" in translation and translation["include"]:
                    selected_translations.append(translation["text"])
        if selected_translations:
            # Some translations contains brackets. Ex: "[[en]] [[bonne]] [[sant√©]]"
            selected_translations = [s.replace("[[", "").replace("]]", "") for s in selected_translations]
            return ", ".join(selected_translations)
        else:
            return None

    def synonyms(self):
        selected_synonyms = []
        if "synonyms" in self.doc:
            for synonym in self.doc["synonyms"]:
                if "include" in synonym and synonym["include"]:
                    selected_synonyms.append(synonym["text"])
        if selected_synonyms:
            return ", ".join(selected_synonyms)
        else:
            return None

    def samples(self):
        result = {}
        for type in self.doc["types"]:
            if "definitions" in type:
                for definition in type["definitions"]:
                    if "quotations" in definition:
                        for quotation in definition["quotations"]:
                            if "card_sample" in quotation and quotation["card_sample"]:
                                regex = re.compile(re.escape(self.title()), re.IGNORECASE)
                                answer = self._escape(quotation["text"])
                                sample = regex.sub("[...]", answer)
                                if "card_sample_hint" in quotation and quotation["card_sample_hint"]:
                                    sample += "<br><br><small>Hint</small> " + definition["text"]
                                result[sample] = answer
        return result

    def definition_cards(self):
        result = []
        for type in self.doc["types"]:
            if "definitions" in type:
                for definition in type["definitions"]:
                    if "card" in definition and definition["card"]:
                        text = "<small>" + self.TYPES_ABBR[type["type"]] + "</small> " \
                               + definition["text"]
                        result.append(self._escape(text))
        return result


    def has_image_card(self):
        if "card_image" not in self.doc:
            return False

        if not self.doc["card_image"]:
            return False

        # If the attribute is true, we need to check a picture is selected
        if "images" in self.doc:
            for image in self.doc["images"]:
                if "include" in image and image["include"]:
                    return True
        return False

    def has_definition_card(self):
        for type in self.doc["types"]:
            if "card_definitions" in type and type["card_definitions"]:
                return True
        return None

    def has_translation_card(self):
        return "card_translate" in self.doc and self.doc["card_translate"]

    def _escape(self, text):
        return text.replace('}', '').replace('{', '')



def load(col, filepath, deck_name):
    """
    Load a single word into Anki. Read the dictionary entry file and try to load the picture and the sound in the same folder if present.
    :param col: the Anki collection reference
    :param filepath: the file path of the JSON document file
    :param deck_name: the name of the Deck to use
    """

    directory = os.path.dirname(filepath)
    basename = os.path.basename(filepath)

    media_directory = os.path.join(os.path.dirname(col.path), "collection.media")

    print("Opening file %s" % filepath)
    with open(filepath, 'r') as f:
        json_content = f.read()
        doc = json.loads(json_content)
        word = Word(doc)

        fields = {}
        fields["Word"] = word.title()
        fields["Rank"] = str(word.rank())
        fields["Types"] = word.abbreviated_types()

        if word.audio_url():
            filename = "%s-%s" % (word.rank(), word.title())
            possible_extensions = ['ogg', 'mp3']
            for extension in possible_extensions:
                audio_name = filename + '.' + extension
                audio_path = os.path.join(directory, audio_name)
                if os.path.exists(audio_path):
                    source_path = audio_path
                    target_path = os.path.join(media_directory, audio_name)
                    print("Copying media file %s to %s" % (source_path, target_path))
                    col.media.addFile(source_path)
                    #shutil.copyfile(source_path, target_path)
                    fields["Sound"] = "[sound:%s]" % audio_name

        fields["DefinitionsWithSamples"] = word.definitions_with_samples()
        if word.has_definition_card():
            fields["DefinitionsOnly"] = word.definitions_only()

        if word.image():
            image_name = "%s-%s-thumb.jpg" % (word.rank(), word.title())
            image_path = os.path.join(directory, image_name)
            if os.path.exists(image_path):
                source_path = os.path.join(directory, image_name)
                target_path = os.path.join(media_directory, image_name)
                print("Copying media file %s to %s" % (source_path, target_path))
                col.media.addFile(source_path)
                #shutil.copyfile(source_path, target_path)
                fields["Image"] = '<img src="%s">' % image_name

        if word.ipa():
            fields["IPA"] = word.ipa()
        if word.translation():
            fields["Translation"] = word.translation()
        if word.synonyms():
            fields["Synonyms"] = word.synonyms()

        samples = word.samples()
        if samples:
            sample_suffixes = ["A", "B", "C"]
            index = 0
            for sample, answer in samples.items():
                if index < 3:
                    fields["Sample" + sample_suffixes[index]] = sample
                    fields["Answer" + sample_suffixes[index]] = answer
                    index += 1

        if word.has_image_card():
            fields["HasImageCard"] = str(word.has_image_card())
        if word.has_definition_card():
            fields["HasDefinitionsCard"] = str(word.has_definition_card())
        if word.has_translation_card():
            fields["HasTranslationCard"] = str(word.has_translation_card())

        definitions = word.definition_cards()
        if definitions:
            definitions_suffixed = ["A", "B"]
            for index, text in enumerate(definitions):
                if index < 2:
                    fields["Definition" + definitions_suffixed[index]] = text

        #print(json.dumps(fields, indent=4))


        # Get the deck
        deck = col.decks.byName(deck_name)

        # Instantiate the new note
        note = col.newNote()
        note.model()['did'] = deck['id']

        # Ordered fields as defined in Anki note type
        anki_fields = ["Word", "Sound", "DefinitionsWithSamples", "DefinitionsOnly", "Image", "IPA", "Translation", "Synonyms", "SampleA", "SampleB", "SampleC", "HasImageCard", "HasDefinitionsCard", "AnswerA", "AnswerB", "AnswerC", "HasTranslationCard", "DefinitionA", "DefinitionB", "Rank", "Types" ]

        for field, value in fields.items():
            note.fields[anki_fields.index(field)] = value

        # Set the tags (and add the new ones to the deck configuration
        tags = "word word-" + str((word.rank() + 1000) // 1000) + '000'
        note.tags = col.tags.canonify(col.tags.split(tags))
        m = note.model()
        m['tags'] = note.tags
        col.models.save(m)

        # Add the note
        col.addNote(note)




if __name__ == '__main__':

    import argparse, glob

    parser = argparse.ArgumentParser()
    parser.add_argument("anki_home", help="Home of your Anki installation")
    parser.add_argument("-d", "--deck", help="Name of the deck in which to create the flashcards", default="English")
    parser.add_argument("-f", "--folder", help="Input folder where to search files", default="../save")
    parser.add_argument("--rank", help="Rank of the word to load", type=int)
    parser.add_argument("--from", help="Rank of the first word to load", type=int, default=0, dest="start")  # reserved word
    parser.add_argument("--to", help="Rank of the last word to load", type=int, default=100000, dest="end")  # to be consistent with start
    parser.add_argument("-v", "--verbose", help="Enable verbose mode", action='store_true')
    parser.set_defaults(verbose=False)
    args = parser.parse_args()

    print("----------------------------------")
    print("Word Loader ----------------------")
    print("----------------------------------")
    print("Anki home: %s\n" % args.anki_home)



    # Load the anki collection
    cpath = os.path.join(args.anki_home, "collection.anki2")
    col = Collection(cpath, log=True)

    # Set the model
    modelBasic = col.models.byName('Word')
    deck = col.decks.byName(args.deck)
    col.decks.select(deck['id'])
    col.decks.current()['mid'] = modelBasic['id']


    if args.rank:

        # Only one word to load
        print("Only rank %d to load" % args.rank)
        glob_pattern = "%d-*.json" % args.rank
        file_pattern = os.path.join(args.folder, glob_pattern)
        print("File pattern: " + file_pattern)
        for filepath in glob.iglob(file_pattern):
            load(col, filepath, args.deck)

    else:

        # Iterate over input folder
        glob_pattern = '[1-9]*-*.json'

        file_pattern = os.path.join(args.folder, glob_pattern)
        for filepath in glob.iglob(file_pattern):
            filename = os.path.basename(filepath)
            rank = int(filename[:filename.index('-')])
            if rank >= args.start and rank < args.end:
                load(col, filepath, args.deck)
            elif args.verbose:
                print("Skipped %s" % filename)


    # Save the changes to DB
    col.save()
